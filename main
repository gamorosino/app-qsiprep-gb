#!/bin/bash
## stuff from jobheader.sh
#PBS -N qsiprep


CPUs_available () {
                        ############# ############# ############# ############# ############# ############# #############
                        #############  Stima il numero di processori liberi a partire dal carico della CPU  ############# 
                        ############# ############# ############# ############# ############# ############# #############                  
                        
			local cpu_load=$( echo $( top -b -n2 | grep "Cpu(s)" | awk '{print $2+$4}' | tail -n1 ))		# calcolo del carico della cpu%
			local cpu_load_f=$(echo "scale=5; ${cpu_load}/100  " | bc)
			local cpu_num_all_n=$(( $( getconf _NPROCESSORS_ONLN )-0 ))	
			local cores_used=$(echo "scale=5; ${cpu_load_f}*${cpu_num_all_n} " | bc)
			local cores_used=${cores_used%.*}
			local cores_used=$(( ${cores_used}-0 ))								# numero processori attalmente in uso
			local cpu_num_all=$(( cpu_num_all_n-$cores_used))							# numero totale processori disponibili
			echo $cpu_num_all

			};


set -x
set -e
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/"
export FREESURFER_LICENSE="hayashis@iu.edu 29511 *CPmh9xvKQKHE FSg0ijTusqaQc"
echo $FREESURFER_LICENSE > license.txt

bl2bids


WORKDIRNAME=$(pwd)/qsipworkdir
outdir=$(pwd)/output

dwi=$(jq -r .dwi config.json)
space=$(jq -r .output_space config.json)
resolution=$(jq -r .output_resolution config.json)
sub=$(jq -r '._inputs[0].meta.subject' config.json)
skipbidsvalidation=$(jq -r .skipbidsvalidation config.json)
denoise_method=$(jq -r .denoise_method config.json)
distortion_group_merge=$(jq -r .distortion_group_merge config.json)
unringing_method=$(jq -r .unringing_method config.json)
hmc_transform=$(jq -r .hmc_transform config.json)
infant=$(jq -r .infant config.json)
syn_sdc=$(jq -r .syn_sdc config.json)
force_syn=$(jq -r .force_syn config.json)
check_flip_bvecs=$(jq -r .check_flip_bvecs config.json)
b1_biascorrect_stage=$(jq -r .b1_biascorrect_stage config.json)
hmc_model=$(jq -r .hmc_model config.json)
pepolar_method=$(jq -r .pepolar_method config.json)

optional=""

# multi-DWI merge option
if [[ $dwi == *","* ]]; then 
    echo "Multi DWI input found. Distortion group merge option: ${distortion_group_merge}"
    optional="$optional --distortion-group-merge ${distortion_group_merge}"
fi

# spatial normalization
if [[ $space == "MNI152NLin2009cAsym" ]]; then
    echo "Performing normalization to MNI152NLin2009cAsym space."
    optional="$optional --anatomical-template MNI152NLin2009cAsym"
fi

# boolean options
[ $skipbidsvalidation == "true" ] && optional="$optional --skip-bids-validation"
[ $infant == "true" ] && optional="$optional --infant"

# --- Smart DWI renaming: sequential runs, optional BidsGuess ---
dwi_use_bidsguess=$(jq -r .dwi_use_bidsguess config.json)
if [[ $dwi_use_bidsguess == "true" ]]; then
    echo "Renaming DWI files sequentially (_run-1, _run-2, ...) with optional BidsGuess override."
    i=1
    find bids/sub-$sub -type f -path "*/dwi/*.json" | sort | while read -r json; do
        base=$(basename "$json" .json)
        dir=$(dirname "$json")

        # define default tag
        run_tag="_run-${i}"
        guess=$(jq -r '.BidsGuess[1] // empty' "$json")

        # if valid BidsGuess, replace run_tag with it
        if [[ -n "$guess" && "$guess" != "null" ]]; then
            tag="$guess"
        else
            tag="$run_tag"
        fi

        echo "Renaming $base files → tag: $tag"

        for fn in "$dir"/$base.*; do
            # Handle both single- and double-extension files (.nii.gz)
            if [[ "$fn" == *.nii.gz ]]; then
                mv "$fn" "$dir/sub-${sub}${tag}_dwi.nii.gz"
            else
                ext="${fn##*.}"
                mv "$fn" "$dir/sub-${sub}${tag}_dwi.${ext}"
            fi
        done

        ((i++))
    done
fi

# clean work/output dirs
rm -rf $WORKDIRNAME && mkdir -p $WORKDIRNAME
rm -rf $outdir && mkdir -p $outdir

# avoid templateflow problems on HPCs
mkdir -p templateflow
export SINGULARITYENV_TEMPLATEFLOW_HOME=$PWD/templateflow

# FreeSurfer license check
[ -z "$FREESURFER_LICENSE" ] && echo "Please set FREESURFER_LICENSE in .bashrc" && exit 1;

# sanity check
tree bids


# --- Sanitize .bval and .bvec files for FSL compliance ---
echo "Fixing malformed .bval/.bvec files in BIDS before QSIPrep..."

find bids -type f -name "*.bval" | while read -r f; do
    vals=$(tr '\n' ' ' < "$f" | sed 's/  */ /g; s/ *$//')
    echo "$vals" > "$f"
    echo "Fixed bval: $f"
done

find bids -type f -name "*.bvec" | while read -r f; do
    # Count lines to see if transposition is needed
    nlines=$(wc -l < "$f")
    if [ "$nlines" -ne 3 ]; then
        echo "↻ Transposing malformed bvec: $f"
        awk '{for(i=1;i<=NF;i++) a[NR,i]=$i} END{for(i=1;i<=NF;i++){for(j=1;j<=NR;j++) printf a[j,i]" "; print ""}}' "$f" > "${f}.tmp"
        mv "${f}.tmp" "$f"
    fi
    echo "Fixed bvec: $f"
done

echo "All .bval/.bvec files are now FSL-compliant."


singularity exec -e  docker://pennlinc/qsiprep:1.0.1 python ./validate_phase_encoding.py bids


#docker://docker://pennlinc/qsiprep:1.0.1 \
# --- Run QSIPrep ---
time singularity exec -e \
     docker://pennbbl/qsiprep:0.24.0 \
    qsiprep \
    --fs-license-file license.txt \
    --anat-modality T1w \
    --output-resolution $resolution \
    --denoise-method $denoise_method \
    --unringing-method $unringing_method \
    --hmc-transform $hmc_transform \
    --hmc-model $hmc_model \
    --b1-biascorrect-stage $b1_biascorrect_stage \
    --pepolar-method $pepolar_method \
    --nthreads $( CPUs_available ) \
    --verbose \
    --work-dir $WORKDIRNAME \
    --stop-on-first-crash \
    $optional \
    bids $outdir participant

echo "done with qsiprep! - now organizing output"
./qsiprep2bl.sh

echo "all done!"
